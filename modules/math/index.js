(function() {
    // Inertia's Math Module V2 [www.khanacademy.org/cs/_/5805810134843392]
    // The Native Math with some additions
    Define("Math", function() {
        var Util = require("Util"), MapFunc = Util.MapArr,
            _ = Util._, Core = require("Core"), $Map,
            Func = Core.Func, Native = Core.Math;
        // Allows for multiple Arguments to solve an Equation
        var Solve = function (formula) {
            var formula = formula || "a + b",
                n = /[\/]/g.test(formula) ? 1 : 0;
            return function () {
                var args = arguments;
                return _.reduce(Util.args(args, n),
                    Func("a", "b", "return Number(" + formula + ");"),
                    /[\*\/]/g.test(formula) ? (n ? args[0] : 1) : 0);
            };
        };

        // Map Of Names And Functions
        $Map = [
            // Pretty Basic But Missing
            [["Add", "add"], Solve()], // Addition
            [["Sub", "sub"], Solve("a - b")], // Subtraction
            [["Div", "div"], Solve("a / b")], // Division
            [["Mult", "mult"], Solve("a * b")], // Multplication
            [["grow", "next"], Func("a", "return a + 1;")], // Next Value
            [["prev"], Func("a", "return a - 1;")], // Prev Value
            // Scale a Value
            [["map", "scale"], function(num) {
                return Core.PJS.map.apply(this, [num]
                    .concat(Util.args(arguments, 1)));
            }],
            // Even & Odd Value
            [["iseven", "isEven", "even"], Func("num", "return num % 2 === 0;")],
            [["isodd", "isOdd", "odd"], Func("num", "return num % 2 === 1;")],
            // Allows for multiple Arguments to solve an Equation
            [["Solve", "solve"], Solve],
            // Scale two values to a percentage to create a new value
            [["lerp"], function (a, b, per) {
                var $lerp = function (a, b, per) {
                    if (typeof a === typeof b ||
                        _.isArray(a) === _.isArray(b)) {
                        if (_.isNumber(a)) { return lerp(a, b, per); }
                        else if (_.isObject(a) && !_.isString(a) &&
                                 !_.isFunction(a)) {
                            return _.reduce(a, function (acc, val, i) {
                                if (!_.isUndefined(b[i]) &&
                                    typeof a[i] === typeof b[i]) {
                                    acc[i] = $lerp(a[i], b[i], per);
                                }
                                return acc;
                            }, _.extend(_.isArray(a) && _.isArray(b) ?
                                    [] : {}, a, b));
                        }
                    }
                };
                return $lerp(a, b, per);
            }]
        ];
        // Extend Methods
        MapFunc(Native, $Map, false, Number);
        MapFunc(Number.prototype, $Map, true);
        return Native;
    });
})(); // Math